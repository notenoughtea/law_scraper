package clients

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"

	"lawScraper/scraper/internal/config"
	"lawScraper/scraper/internal/logger"
)

type TelegramMessage struct {
	ChatID    string `json:"chat_id"`
	Text      string `json:"text"`
	ParseMode string `json:"parse_mode,omitempty"`
}

func SendTelegramMessage(message string) error {
	logger.Log.Info("=== –ù–∞—á–∞–ª–æ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram ===")
	
	token := config.GetTelegramToken()
	chatID := config.GetTelegramChatID()

	logger.Log.Infof("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: Token=%s, ChatID=%s", 
		maskToken(token), chatID)

	if token == "" || chatID == "" {
		logger.Log.Error("‚ùå Telegram bot token –∏–ª–∏ chat id –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã!")
		logger.Log.Errorf("Token –ø—É—Å—Ç–æ–π: %v, ChatID –ø—É—Å—Ç–æ–π: %v", token == "", chatID == "")
		return fmt.Errorf("telegram bot token –∏–ª–∏ chat id –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
	}

	url := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", token)
	logger.Log.Infof("URL –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏: https://api.telegram.org/bot***HIDDEN***/sendMessage")

	msg := TelegramMessage{
		ChatID:    chatID,
		Text:      message,
		ParseMode: "HTML",
	}

	logger.Log.Infof("–§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è: ChatID=%s, –î–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞=%d, ParseMode=%s", 
		chatID, len(message), "HTML")
	logger.Log.Debugf("–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è: %s", message)

	jsonData, err := json.Marshal(msg)
	if err != nil {
		logger.Log.Errorf("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: %v", err)
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: %w", err)
	}
	logger.Log.Infof("‚úì –°–æ–æ–±—â–µ–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞–Ω–æ, —Ä–∞–∑–º–µ—Ä JSON: %d –±–∞–π—Ç", len(jsonData))

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		logger.Log.Errorf("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è HTTP –∑–∞–ø—Ä–æ—Å–∞: %v", err)
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	logger.Log.Info("‚úì HTTP –∑–∞–ø—Ä–æ—Å —Å–æ–∑–¥–∞–Ω")

	logger.Log.Info("–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –≤ Telegram API...")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logger.Log.Errorf("‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è HTTP –∑–∞–ø—Ä–æ—Å–∞: %v", err)
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: %w", err)
	}
	defer resp.Body.Close()

	logger.Log.Infof("–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç Telegram API: Status=%d (%s)", 
		resp.StatusCode, resp.Status)

	body, readErr := io.ReadAll(resp.Body)
	if readErr != nil {
		logger.Log.Warnf("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: %v", readErr)
	} else {
		logger.Log.Infof("–¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞ –æ—Ç Telegram API: %s", string(body))
	}

	if resp.StatusCode != http.StatusOK {
		logger.Log.Errorf("‚ùå Telegram API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: %s", resp.Status)
		return fmt.Errorf("telegram api –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: %s, —Ç–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: %s", resp.Status, string(body))
	}

	logger.Log.Info("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram")
	logger.Log.Info("=== –ö–æ–Ω–µ—Ü –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram ===")
	return nil
}

// maskToken –º–∞—Å–∫–∏—Ä—É–µ—Ç —Ç–æ–∫–µ–Ω –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
func maskToken(token string) string {
	if token == "" {
		return "<–ü–£–°–¢–û>"
	}
	if len(token) < 10 {
		return "***"
	}
	return token[:4] + "..." + token[len(token)-4:]
}

func SendFileURLWithKeywords(fileURL string, keywords []string, pubDate string, title string, description string) error {
	logger.Log.Infof("üì§ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥–ª—è —Ñ–∞–π–ª–∞: %s", fileURL)
	logger.Log.Infof("–ù–∞–π–¥–µ–Ω–æ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤: %d (%v)", len(keywords), keywords)
	logger.Log.Infof("–î–∞—Ç–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: %s", pubDate)
	logger.Log.Infof("–ó–∞–≥–æ–ª–æ–≤–æ–∫: %s", title)
	
	keywordsStr := ""
	if len(keywords) > 0 {
		keywordsStr = keywords[0]
		for i := 1; i < len(keywords); i++ {
			keywordsStr += ", " + keywords[i]
		}
	}

	// –§–æ—Ä–º–∏—Ä—É–µ–º caption –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∞
	caption := "üîç <b>–ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ</b>\n\n"
	
	if title != "" {
		caption += fmt.Sprintf("üìã <b>%s</b>\n\n", title)
	}
	
	if description != "" {
		// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É description –¥–ª—è Telegram (–º–∞–∫—Å 1024 —Å–∏–º–≤–æ–ª–∞ –¥–ª—è caption)
		maxDescLen := 500
		desc := description
		if len(desc) > maxDescLen {
			desc = desc[:maxDescLen] + "..."
		}
		caption += fmt.Sprintf("üìù %s\n\n", desc)
	}
	
	caption += fmt.Sprintf("üîë <b>–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞:</b> %s", keywordsStr)
	
	if pubDate != "" {
		caption += fmt.Sprintf("\nüìÖ <b>–î–∞—Ç–∞:</b> %s", pubDate)
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∂–∏–º –æ—Ç–ø—Ä–∞–≤–∫–∏ (–æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏ —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é)
	sendAsDocument := config.GetTelegramSendAsDocument()
	
	if sendAsDocument {
		logger.Log.Info("–†–µ–∂–∏–º: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç –≤ Telegram")
		// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç
		return SendDocumentToTelegram(fileURL, caption)
	}

	// –†–µ–∂–∏–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Ñ–∞–π–ª
	logger.Log.Info("–†–µ–∂–∏–º: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Ñ–∞–π–ª")
	
	message := "üîç <b>–ù–∞–π–¥–µ–Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ</b>\n\n"
	
	if title != "" {
		message += fmt.Sprintf("üìã <b>%s</b>\n\n", title)
	}
	
	message += fmt.Sprintf("üìÑ <b>–§–∞–π–ª:</b> <a href=\"%s\">–°–∫–∞—á–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç</a>\n", fileURL)
	
	if description != "" {
		// –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É description
		maxDescLen := 500
		desc := description
		if len(desc) > maxDescLen {
			desc = desc[:maxDescLen] + "..."
		}
		message += fmt.Sprintf("üìù %s\n\n", desc)
	}
	
	message += fmt.Sprintf("üîë <b>–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞:</b> %s", keywordsStr)
	
	if pubDate != "" {
		message += fmt.Sprintf("\nüìÖ <b>–î–∞—Ç–∞:</b> %s", pubDate)
	}
	
	// –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞
	if !hasExtension(fileURL) {
		message += "\n\nüí° <i>–ü–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ–∏–º–µ–Ω—É–π—Ç–µ —Ñ–∞–π–ª, –¥–æ–±–∞–≤–∏–≤ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ .docx</i>"
	}

	logger.Log.Infof("–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (–¥–ª–∏–Ω–∞: %d —Å–∏–º–≤–æ–ª–æ–≤)", len(message))
	
	err := SendTelegramMessage(message)
	if err != nil {
		logger.Log.Errorf("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –¥–ª—è %s: %v", fileURL, err)
		return err
	}
	
	logger.Log.Infof("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è %s –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ", fileURL)
	return nil
}

// hasExtension –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –≤ URL
func hasExtension(url string) bool {
	// –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–∏–ø–∏—á–Ω—ã—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
	extensions := []string{".docx", ".doc", ".pdf", ".txt", ".xlsx", ".xls"}
	for _, ext := range extensions {
		if len(url) >= len(ext) && url[len(url)-len(ext):] == ext {
			return true
		}
	}
	return false
}

// SendDocumentToTelegram –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ–∞–π–ª –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç –≤ Telegram
func SendDocumentToTelegram(fileURL string, caption string) error {
	token := config.GetTelegramToken()
	chatID := config.GetTelegramChatID()

	if token == "" || chatID == "" {
		return fmt.Errorf("telegram bot token –∏–ª–∏ chat id –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
	}

	logger.Log.Infof("–°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å %s...", fileURL)
	
	// –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
	resp, err := http.Get(fileURL)
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞: —Å—Ç–∞—Ç—É—Å %d", resp.StatusCode)
	}

	fileData, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: %w", err)
	}

	logger.Log.Infof("–§–∞–π–ª —Å–∫–∞—á–∞–Ω, —Ä–∞–∑–º–µ—Ä: %d –±–∞–π—Ç", len(fileData))

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª –≤ Telegram
	url := fmt.Sprintf("https://api.telegram.org/bot%s/sendDocument", token)

	// –°–æ–∑–¥–∞–µ–º multipart form
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// –î–æ–±–∞–≤–ª—è–µ–º chat_id
	_ = writer.WriteField("chat_id", chatID)
	
	// –î–æ–±–∞–≤–ª—è–µ–º caption
	if caption != "" {
		_ = writer.WriteField("caption", caption)
		_ = writer.WriteField("parse_mode", "HTML")
	}

	// –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–π–ª
	part, err := writer.CreateFormFile("document", "document.docx")
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è form file: %w", err)
	}
	
	if _, err := part.Write(fileData); err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ —Ñ–∞–π–ª–∞: %w", err)
	}

	writer.Close()

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞: %w", err)
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())

	client := &http.Client{}
	logger.Log.Info("–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ Telegram...")
	
	apiResp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞: %w", err)
	}
	defer apiResp.Body.Close()

	respBody, _ := io.ReadAll(apiResp.Body)
	
	if apiResp.StatusCode != http.StatusOK {
		logger.Log.Errorf("‚ùå –û—à–∏–±–∫–∞ Telegram API: %s, —Ç–µ–ª–æ: %s", apiResp.Status, string(respBody))
		return fmt.Errorf("telegram api –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: %s", apiResp.Status)
	}

	logger.Log.Info("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ Telegram")
	return nil
}

